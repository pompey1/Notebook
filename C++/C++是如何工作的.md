# 概述
书接上回
``` C++
#include <iostream>
```
预处理命令，编译器不会直接处理
``` C++
int main() {
	std::cout << "Hello World" << std::endl;
	std::cin.get();
}
```
main方法，程序的入口，特殊点：如果没有返回值，main函数会自动**返回0**

**<<** 符号：重载运算符，你可以将它看做函数，他的作用相当于
```
std::cout.print("Helllo World").print(endl)
```
每一个cpp文件经过编译会生成一个obj文件，链接器（Link）在obj中找到符合声明的函数（找不到会报外部链接是失败的错，看起来很唬人），之后将所有obj组合成exe文件

# C++编译器是如何工作的
+ C++编译器并不在乎文件，他只在乎文件传输的内容，你甚至可以乱取一个后缀名，只要你让你的编译器像对待cpp文件一样对待他，效果都一样
+ 在解决方案的属性中，将预处理器的预处理到文件设置为yes，通过ctrl+F7编译一个cpp文件，你会获得一个**i文件**，你可以通过i文件观察通过预处理后的代码

例1 #include

文件test.h内容，因为编译器不会编译头文件，所以不会报错
```
}
```

另外一个文件
``` C++
#include <iostream>
int main(){
#include "test.h" //作用相当于编译器将}复制黏贴到这里
//这样写编译器能通过，很神奇吧
```

例2 #if
``` C++
#if 1
    //有效的代码
#endif

#if 0
    //无效代码，编译器会在预处理的时候删除
#endif
```
+ 在解决方案的属性中，将输出文件中的汇编程序输出设置为仅有程序集的列表，编译cpp文件你会获得一个**asm**，文件，通过它你可以观察到编译出的汇编程序具体和寄存器做出了什么交互，并且你可以看到你写的函数都被写上了特殊签名，链接器正是通过这个特殊签名来链接不同obj文件的函数
# C++链接器是如何工作的
错误的前缀名为LNK时，说明报错是发生在链接器阶段，错误的欠前缀名为C时，说明报错是发生在编译器阶段

用static关键词修饰函数以后，这个函数只能在这个**翻译单元**(即obj文件)中调用，对于其他翻译单元来说**不可见**，所以当static修饰的方法并没有在这个翻译单元中调用时，链接器不会报LNK错误

inline关键词修饰函数以后，该函数的调用会直接变成函数体，相当于该函数所在的文件中**只剩下了函数的声明，没有函数的定义**，所以不会造成LNK报错