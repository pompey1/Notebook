# 非Class的Enum

``` C++
class Log{
public:
    enum Level{
        Info = 0, Warning = 1, Error = 2
    }
}； 
```
这里的枚举并不是枚举类，他不是一个命名空间，所以调用Info的时候用的的Log::Info,而不是Level::Info

> 这里还有一个小细节，同一个命名空间下不能有相同的名字，**即使是函数和变量重名也不行**，也会报错

# 构造函数
C++中，就算一个对象**只是声明**，同样会调用他的构造函数，C#中，有待确认

在Java这些语言中，基础类型变量会被自动赋值为0，但是C++不行，必须手动给所有基础类型变量赋值

如果你只是运行一个类的静态方法，那么构造函数并不会执行，C++为所有类提供了一个默认的构造函数，如果你不想让这个类被实例化，可以用private来修饰一下，或者**给构造函数赋值delete**

如果是对象（值类型），声明时在对面后面添加（）和构造函数的参数，如果是对象指针（引用类型），在new的后面添加（）和构造函数的参数

# 析构函数
当对象在栈内存中时，作用域一结束，就会调用析构函数。当对象被delete时，也会调用析构函数