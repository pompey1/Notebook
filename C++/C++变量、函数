# 概述

事实上，**在C++中**不同原始变量类型的唯一区别只在于他所占内存空间的大小不同。

# int
Int类型占据四个字节大小（32位，默认有一位用来表示符号，如果你不想用这一位来表示符号，你可以用```unsigned```来修饰这个变量）

# char
占据一个字节大小

# short
占据两个字节大小

# long
通常也占据四个字节大小（不同编译器大小不同）

# long long
通常占据八个字节大小（不同编译器大小不同）

# float
占据四个字节大小

# double
占据八个字节大小

# bool
占据一个字节大小（照理来说，bool类型只需要一个bit就足够表达，但是当我们寻址内存时，我们需要从内存中找回这个bool变量的值，我们不能寻址只有一个bit的内容，**字节是寻址的最小单位**，我们只能寻址至少一个字节的内容）

> 但是你可以在一个byte中存储八个bool变量，我们以后可能会讨论到类似的高级技巧，但是目前为止还是算了，让我们记住一个bool占据一个字节大小

# sizeof()

本质上是一个计算符，用来返回一个类型所占的内存大小，**这个大小和编译器相关**。

# 指针和引用

C++同时支持指针和引用（C语言只支持指针不支持引用，C#只支持引用不支持指针，除非使用unsafe代码）

声明时在类型名称后面添加 * 就是指针，在类型名称后面添加 & 就是引用

# 函数

每次调用一个函数的时候，编译器会生成一个call指令

这就意味着，在一个运行的程序中，为了调用一个函数，我们需要创建一个**堆栈结构**，我们需要将参数push进这个堆栈，还需要将一个叫做**返回地址**的东西push入堆栈，然后我们要做的是跳到二进制执行文件的不同部分，以便开始执行我们的函数指令

为了将我们push进去的结果返回，我们又得回到函数调用之前，就像在内存中**跳跃**，这些都需要时间，会减缓程序执行的速度，所以不要强求将所有代码封装成函数

> 当然，前提是我们不用inline这个内联修饰符来修饰函数，此时函数被编译器认为是实际的函数，所以会跳转执行，以后我们会具体讨论**内联**

习惯上，我们在h文件中声明函数，在cpp文件中定义函数

# 头文件

VS中的文件夹其实并不是文件夹，他只是一个过滤器，所以你在考虑相对路径的时候不要将它考虑在内

创建h文件时，编译器会帮你自动生成#program once预处理指令，他的作用相当于
``` C++
#ifndef ZHIPENG_TEST
#define ZHIPENG_TEST
//只执行一次的代码块，执行过一次以后ZHIPENG_TEST就会被define了，所以之后不会再执行
#endif
```
还是更建议使用#program once,这样更简洁，这个预处理命令的作用是避免你多次调用该头文件，导致重复的声明

include的""最好养成习惯，用来表示当前文件的相对路径（其实能表示所有路径），<>则表示编译器指定路径，通常是C++提供的标准库

为了使C++标准库文件区别于C语言，C++标准库文件没有加后缀名，而C语言的标准库文件往往是h文件，这是一种区分C和C++标准库的方法