# 采样 Sampling 走样 Aliasing

光栅化的采样：将理论上平滑连续的三角面（三个顶点定义）转换成离散的像素点

函数的采样：将原始的函数与冲积函数相乘，获取原始函数的离散信息

采样的本质：重复原始信息的频谱 

走样的本质：采样频率不够会导致频谱的相互重叠，从而导致信息丢失

# 采样错误 Arctifact

1. 锯齿 Jaggies
2. 摩尔纹 Moire
3. 车轮效应 Wagon wheel effect

原因：信号频率太高，采样速度跟不上
解决方法：先滤波，再采样 

# 傅里叶变换和逆傅里叶变换 Fourier Transform

傅里叶变换：时域图=>频域图

逆傅里叶变换：频域图=>时域图

# 滤波 Filter

滤波的本质：在频域图中对高频信息或者低频信息进行修改再通过逆傅里叶变换变回时域图

高通滤波：只剩下高频信息（只剩下图像中的边界）

低通滤波：只剩下低频信息（去除图像中的边界，模糊Blur的一种实现方式）

中通滤波：只剩下中频信息（具体频率高低可以自己定义）

现在的滤波更多是使用机器学习的方法来实现的，不需要自己决定滤波的高低

# 卷积 Convolution

时域的卷积：图片 * 卷积核 = 处理后的图片

频域的乘积：频谱 * 卷积核的频谱 = 处理后的频谱

# 反走样的方案

1. 提高采样频率（直接提高屏幕分辨率）

2. 模糊原始信号，减少高频消息，避免频谱重叠

# 抗锯齿

超采样 MSAA：将一个像素分成更多像素作为采样点（工业界中采样点的分布并不规律），很吃性能

本质上也是一种Blur的方案，并没有直接提高采样频率

其他的抗锯齿方案：FXAA TAA 

# 超分辨率

DLSS：细节缺失通过深度学习来补充

# 深度缓冲

在渲染管线中属于片段着色器后的逐片段操作阶段

画家算法：以三角形为单位进行排序，很难处理三角形重叠的问题（透明物体不能采用深度测试的方法，所以也会遇到这种问题）

Z-Buffer算法：以像素为单位进行排序，并且没有顺序的要求，符合GPU的并发特征，不能用来处理透明物体，需要特殊处理，深度相同会导致ZFighting，画面表现为闪烁，因为每一帧都在覆盖像素

深度缓存中存储的z值是观察坐标系中z值经过MVP变换以后的值，本质上上是一个观察坐标系z值大小的非线性方程：意义，距离摄像机很近的地方，占据了大半的深度取值范围，离摄像机越远的物体，信息就越少，对画面的贡献也越少，根本不需要为远处物体的数据提供更高的精度





